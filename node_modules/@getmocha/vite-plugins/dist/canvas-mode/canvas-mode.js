import path from 'path';
import _generate from '@babel/generator';
import { parse } from '@babel/parser';
import _traverse from '@babel/traverse';
import * as t from '@babel/types';
import { injectedClientModule } from '../injectedClientModule.js';
import * as constants from './canvas-mode-constants.js';
// @ts-expect-error Handle differences in import between runtimes.
const generate = _generate.default || _generate;
// @ts-expect-error Handle differences in import between runtimes.
const traverse = _traverse.default || _traverse;
const { CANVAS_ID_ATTR, CANVAS_EDITABLE_ATTR, CANVAS_TEXT_ATTR } = constants;
const CANVAS_MODE_ATTRS = new Set([CANVAS_ID_ATTR, CANVAS_EDITABLE_ATTR, CANVAS_TEXT_ATTR]);
const ALLOWED_INLINE_TAGS = new Set([
    'b',
    'strong',
    'i',
    'em',
    'u',
    's',
    'del',
    'span',
    'sup',
    'sub',
    'br',
]);
const LIBS_TO_IGNORE = new Set(['@react-three/drei', '@react-three/fiber', 'three']);
const srcFileCache = new Map();
const updatedFilesCache = new Map();
const transformableModules = new Set();
export function canvasMode(env) {
    let __mochaCanvasModeEnabled = false;
    const injectedModule = injectedClientModule('canvas-mode', env, { constants });
    return {
        name: 'mocha-canvas-mode',
        enforce: 'pre',
        // See: https://vite.dev/guide/using-plugins#conditional-application
        apply: 'serve',
        ...injectedModule,
        load(id) {
            const cachedFile = getCachedUpdatedFile(id);
            if (cachedFile) {
                return cachedFile;
            }
            return injectedModule.load(id);
        },
        transform(srcCode, filePath) {
            if (!filePath.endsWith('.tsx') && !filePath.endsWith('.jsx'))
                return;
            // TODO: detect modules w/inconsistent exports
            if (filePath.endsWith('Context.tsx'))
                return;
            transformableModules.add(filePath);
            if (!__mochaCanvasModeEnabled)
                return;
            debugTime(`transform ${filePath}`);
            const result = transformJSX(srcCode, filePath);
            debugTimeEnd(`transform ${filePath}`);
            return result;
        },
        configureServer(server) {
            server.ws.on('mocha:canvas:toggle-canvas-mode', async ({ isEnabled }) => {
                __mochaCanvasModeEnabled = isEnabled;
                const paths = [];
                for (const path of transformableModules) {
                    paths.push(path.replace('/app', ''));
                }
                invalidateModules(paths, server);
            });
            server.ws.on('mocha:canvas:update-element', async ({ elementId, text }, client) => {
                try {
                    const { code, filePath } = replaceTextAndStripSourceAttributes(elementId, text);
                    setCachedUpdatedFile(filePath, code);
                    invalidateModules([filePath], server);
                    client.send('mocha:canvas:file-updated', {
                        path: filePath,
                        content: code,
                    });
                }
                catch {
                    console.log('[mocha-canvas-mode] Error updating element');
                }
            });
        },
        async handleHotUpdate({ file, read, modules }) {
            if (updatedFilesCache.has(file)) {
                updatedFilesCache.delete(file);
            }
            if (file.endsWith('.tsx') || file.endsWith('.jsx')) {
                // Make sure we're able to read the updated contents.
                // See https://vite.dev/guide/api-plugin.html#handlehotupdate
                await read();
            }
            return modules;
        },
    };
    function debugTime(msg) {
        if (env.DEBUG_LOGS === 'true') {
            console.time(`[mocha-canvas-mode] ${msg}`);
        }
    }
    function debugTimeEnd(msg) {
        if (env.DEBUG_LOGS === 'true') {
            console.timeEnd(`[mocha-canvas-mode] ${msg}`);
        }
    }
}
export function transformJSX(srcCode, filePath) {
    const { ast } = addSourceAttributes(srcCode, filePath);
    return generate(ast, {
        sourceMaps: true,
        retainLines: true,
        comments: true,
        sourceFileName: filePath,
    }, srcCode);
}
// Annotate editable elements with identifier and data we can use to attach behavior / lookup later.
export function addSourceAttributes(srcCode, filePath) {
    const ast = parse(srcCode, {
        sourceType: 'module',
        plugins: ['jsx', 'typescript'],
    });
    const normalizedFilePath = filePath.replace('/app/', '');
    const elements = new Map();
    const importSourceMap = new Map();
    function isFromIngoredLib(path) {
        return (t.isJSXElement(path.node) &&
            t.isJSXOpeningElement(path.node.openingElement) &&
            t.isJSXIdentifier(path.node.openingElement.name) &&
            importSourceMap.has(path.node.openingElement.name.name) &&
            LIBS_TO_IGNORE.has(importSourceMap.get(path.node.openingElement.name.name)));
    }
    traverse(ast, {
        ImportDeclaration(path) {
            const source = path.node.source.value;
            for (const specifier of path.node.specifiers) {
                if (t.isImportSpecifier(specifier) || t.isImportDefaultSpecifier(specifier)) {
                    importSourceMap.set(specifier.local.name, source);
                }
            }
        },
        JSXElement(path) {
            if (!path.node.loc)
                return;
            const { type, isEditable, textContent } = analyzeJSXElement(path);
            // Don't annotate structural elements.
            if (type === 'structural')
                return;
            // Don't annotate elements that are blank.
            if (type === 'static' && textContent === '')
                return;
            // Don't annotate elements from certain libraries.
            if (isFromIngoredLib(path))
                return;
            // Add unique id to the tag, and cache it for later retrieval.
            const elementId = `${normalizedFilePath}:${path.node.loc.start.line}:${path.node.loc.start.column}`;
            path.node.openingElement.attributes.push(t.jsxAttribute(t.jsxIdentifier(CANVAS_ID_ATTR), t.stringLiteral(elementId)));
            path.node.openingElement.attributes.push(t.jsxAttribute(t.jsxIdentifier(CANVAS_EDITABLE_ATTR), t.stringLiteral(isEditable ? 'true' : 'false')));
            path.node.openingElement.attributes.push(t.jsxAttribute(t.jsxIdentifier(CANVAS_TEXT_ATTR), t.stringLiteral(encodeURIComponent(textContent))));
            elements.set(elementId, path);
        },
    });
    srcFileCache.set(normalizedFilePath, { ast, elements });
    return { ast };
}
export function replaceTextAndStripSourceAttributes(elementId, text) {
    const data = getCachedElementData(elementId);
    if (!data) {
        throw new Error(`Element with id ${elementId} not found.`);
    }
    const { filePath, ast, element } = data;
    replaceText({ element, text });
    const { code } = stripSourceAttributes({ ast });
    return { code, filePath };
}
// Strip generated attrs from AST before regnerating code.
export function stripSourceAttributes({ ast }) {
    traverse(ast, {
        JSXElement(path) {
            path.node.openingElement.attributes = path.node.openingElement.attributes.filter((attr) => !(t.isJSXAttribute(attr) &&
                t.isJSXIdentifier(attr.name) &&
                CANVAS_MODE_ATTRS.has(attr.name.name)));
        },
    });
    return {
        ast,
        code: generate(ast).code,
    };
}
function replaceText({ element, text }) {
    element.node.children = [t.jsxText(text)];
}
function analyzeJSXElement(path) {
    const { type, text } = extractTextFast(path.node);
    return {
        type,
        isEditable: type === 'static' && text.length > 0,
        textContent: type === 'static' ? text : '',
    };
}
const textContentCache = new WeakMap();
function extractTextFast(node) {
    if (textContentCache.has(node)) {
        return textContentCache.get(node);
    }
    let type = 'static';
    let text = '';
    for (const child of node.children) {
        if (t.isJSXText(child)) {
            text += child.value;
        }
        else if (t.isJSXExpressionContainer(child)) {
            const expr = child.expression;
            if (t.isStringLiteral(expr)) {
                text += expr.value;
            }
            else if (t.isTemplateLiteral(expr)) {
                text += expr.quasis.map((q) => q.value.cooked).join('');
                if (expr.expressions.length > 0) {
                    type = 'dynamic';
                }
            }
            else {
                type = 'dynamic';
            }
        }
        else if (t.isJSXElement(child)) {
            const name = child.openingElement.name;
            if (!t.isJSXIdentifier(name) || !ALLOWED_INLINE_TAGS.has(name.name)) {
                type = 'structural';
                break;
            }
            const inner = extractTextFast(child);
            text += inner.text;
            if (inner.type === 'structural') {
                type = 'structural';
                break;
            }
            else if (inner.type === 'dynamic') {
                type = 'dynamic';
            }
        }
        else {
            // Unknown/unsupported child
            type = 'structural';
            break;
        }
    }
    text = text.trim();
    const result = { type, text };
    textContentCache.set(node, result);
    return result;
}
async function invalidateModules(filePaths, server) {
    const paths = filePaths.map((filePath) => (filePath.startsWith('/') ? filePath : '/' + filePath));
    const modules = await Promise.all(paths.map((path) => server.moduleGraph.getModuleByUrl(path)));
    const pathsAndModules = paths
        .map((path, i) => ({ path, module: modules[i] }))
        .filter(({ module }) => !!module);
    const now = Date.now();
    const updates = pathsAndModules.map(({ module, path }) => {
        server.moduleGraph.invalidateModule(module);
        return {
            type: 'js-update',
            path: path,
            acceptedPath: path,
            timestamp: now,
        };
    });
    server.hot.send({ type: 'update', updates: updates });
}
function setCachedUpdatedFile(filePath, code) {
    const key = path.resolve(filePath);
    return updatedFilesCache.set(key, code);
}
function getCachedUpdatedFile(filePath) {
    const key = path.resolve(filePath);
    return updatedFilesCache.get(key);
}
function getCachedElementData(jsxid) {
    for (const [filePath, { ast, elements }] of srcFileCache.entries()) {
        const element = elements.get(jsxid);
        if (element) {
            return { element, filePath, ast };
        }
    }
}
